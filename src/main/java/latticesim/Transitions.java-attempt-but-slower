package latticesim;

import java.util.ArrayList;

import com.google.gson.Gson;

public class Transitions {
    private class Transition {
        // Linked list, the transient is just to exclude this from the
        // gson toJson() output
        //transient Transition next;

        double rate;
        int c;
        int position;
        int window;

        // These are needed to count event stats
        int ispec;
        int fromC;

        Transition(double rate, int c, int position, int window,
             int ispec, int fromC) {

            this.rate = rate;
            this.c = c;
            this.position = position;
            this.window = window;
            this.ispec = ispec;
            this.fromC = fromC;
        }

        public String toString() {
            Gson gson = new Gson();

            return gson.toJson(this);
        }
    }

    private LatticeConfiguration config;

    private SimOptions.LocalTransitionSpec [] specs;
    private int froms[];
    private int tos[];
    private int maxSpecWindow;

    private ArrayList<Transition> [] transitions;
    private int [] slotsUsed;

    private double exitRate;

    /**
     * Construct a Transitions object, which will calculate the
     * allowed transitions for the given LatticeConfiguration according
     * to the list of LocalTransitionSpec objects.
     */
    public Transitions(
        LatticeConfiguration config,
        SimOptions.LocalTransitionSpec [] specs
    ) {
        this.config = config;

        this.specs = specs;

        // Copy the ranges, but as absolute indices, and zero indexed
        this.froms = new int[specs.length];
        this.tos = new int[specs.length];

        int L = config.getLength();

        for (int i = 0; i < specs.length; i++) {
            froms[i] = specs[i].from;

            if (froms[i] < 0) {
                // e.g. for negative indices, last site is -1 -> L - 1
                froms[i] += L;
            } else {
                // For positive indices, first site is 1 -> 0
                froms[i] -= 1;
            }

            tos[i] = specs[i].to;

            if (tos[i] < 0) {
                tos[i] += L;
            } else {
                tos[i] -= 1;
            }

            // Update maxSpecWindow
            if (specs[i].window > maxSpecWindow) {
                maxSpecWindow = specs[i].window;
            }
        }

        // Now calculate the initial transitions

        // XXX TODO Fix this warning
        //transitions = (ArrayList<Transition> []) new Object[L];
        transitions = (ArrayList<Transition> []) new ArrayList[L];
        slotsUsed = new int[L];

        for (int i = 0; i < L; i++) {
            transitions[i] = new ArrayList<Transition>();
        }

        for (int i = 0; i < specs.length; i++) {
            SimOptions.LocalTransitionSpec spec = specs[i];

            for (int j = froms[i]; j <= tos[i]; j++) {
                int c = config.getConfigurationInt(j, spec.window);

                for (int n = 0; n < spec.rates.length; n++) {
                    double rate = spec.rates[n][c];

                    if (rate > 0) {
                        exitRate += rate;

                        addTransition(rate, n, j, spec.window, i, c);
                    }
                }
            }
        }
    }

    /**
     * Add a Transition object to the list.
     */
    private void addTransition(double rate, int c, int position, int window,
            int ispec, int fromC) {
        if (slotsUsed[position] == transitions[position].size()) {
            transitions[position].add(
                new Transition(rate, c, position, window, ispec, fromC)
            );
        } else {
            Transition transition
                = transitions[position].get(slotsUsed[position]);

            transition.rate = rate;
            transition.c = c;
            transition.position = position;
            transition.window = window;
            transition.ispec = ispec;
            transition.fromC = fromC;
        }

        slotsUsed[position]++;
    }

    /**
     *  Recalculate transitions depending on sites
     *      position, ..., position + window -1
     *
     *  Call clearDirty() before this.
     */
    private void recalculate(int position, int window) {
        for (int i = 0; i < specs.length; i++) {
            SimOptions.LocalTransitionSpec spec = specs[i];

            int jstart = Math.max(froms[i], position - maxSpecWindow + 1);
            int jend = Math.min(tos[i], position + window - 1);

            for (int j = jstart; j <= jend; j++) {
                int c = config.getConfigurationInt(j, spec.window);

                for (int n = 0; n < spec.rates.length; n++) {
                    double rate = spec.rates[n][c];

                    if (rate > 0) {
                        exitRate += rate;

                        addTransition(rate, n, j, spec.window, i, c);
                    }
                }
            }

        }
    }

    /**
     * Get the total exit rate.
     */
    public double getExitRate() {
        return exitRate;
    }

    /**
     *  Randomly select then perform a transition according to r:
     *  update the lattice configuration, then recalculate affected
     *  transitions.
     *
     *  @param r a random double value in range [0, this.getExitRate()).
     */
    public void doTransition(double r) {
        // Find the first transition such that the partial sum
        // of rates is greater than r

        double rateSum = 0.0;

        for (int i = 0; i < slotsUsed.length; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                Transition transition = transitions[i].get(j);

                rateSum += transition.rate;

                if (r < rateSum) {
                    config.setConfiguration(
                        transition.c, transition.position, transition.window);

                    // Remove affected transitions
                    clearDirty(transition.position, transition.window);

                    // Then recalculate them
                    recalculate(transition.position, transition.window);

                    return;
                }
            }
        }
    }

    /**
     *  Like the above but record statistics.
     */
    public void doTransition(double r, DensityStatistics stats) {
        // Find the first transition such that the partial sum
        // of rates is greater than r

        double rateSum = 0.0;

        for (int i = 0; i < slotsUsed.length; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                Transition transition = transitions[i].get(j);

                rateSum += transition.rate;

                if (r < rateSum) {
                    config.setConfiguration(
                        transition.c, transition.position, transition.window);

                    // Remove affected transitions
                    clearDirty(transition.position, transition.window);

                    // Then recalculate them
                    recalculate(transition.position, transition.window);

                    stats.countTransition(
                        transition.ispec, transition.c, transition.fromC);

                    return;
                }
            }
        }
    }

    /**
     *  Clear transitions depending on sites
     *      position, ..., position + window -1
     */
    private void clearDirty(int position, int window) {
        int i1 = Math.max(0, position - maxSpecWindow + 1);
        int i2 = position + window;

        for (int i = i1; i < i2; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                exitRate -= transitions[i].get(j).rate;
            }

            slotsUsed[i] = 0;
        }
    }

    /**
     * For debugging: dump the list of transitions.
     */
    void dump() {
        for (int i = 0; i < slotsUsed.length; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                System.out.println(transitions[i].get(j));
            }
        }
    }

    /**
     *  Return array of the current transition list with information
     *  about each transition as a JSON string.
     *
     *  This method is meant for testing/debugging.
     */
    String [] transitionsJSON() {
        // Count the number of transitions
        int numTransitions = 0;

        for (int i = 0; i < slotsUsed.length; i++) {
            numTransitions += slotsUsed[i];
        }

        String [] jsonTransitions = new String[numTransitions];

        int k = 0;

        for (int i = 0; i < slotsUsed.length; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                jsonTransitions[k] = transitions[i].get(j).toString();

                k++;
            }
        }

        return jsonTransitions;
    }

    /**
     * XXX This method really is only meant for testing.
     *
     * Force a transition to occur, specified by a string as returned
     * by transitionsJson().
     */
    void forceTransition(String transitionSpec) {
        for (int i = 0; i < slotsUsed.length; i++) {
            for (int j = 0; j < slotsUsed[i]; j++) {
                Transition transition = transitions[i].get(j);

                if (transitionSpec.equals(transition.toString())) {
                    config.setConfiguration(
                        transition.c, transition.position, transition.window);

                    // Remove affected transitions
                    clearDirty(transition.position, transition.window);

                    // Then recalculate them
                    recalculate(transition.position, transition.window);

                    return;
                }
            }
        }
    }
}
